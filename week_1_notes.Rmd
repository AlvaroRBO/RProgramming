---
title: "Week one part one objects "
author: "Al"
date: "2026-01-06"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R programming Course notes

Following the first course beginnings. They are telling me how to begin to understand the syntax of R. For example

```{r}
x <- 1 ## <- assignment of value to a variable. This line is assigning the value 1 to the variable x
print(x) ## outputs in the terminal the value of x
x ## Auto-prints the value of x

msg <- "Hello" ## Assigning a string
msg

x <- 1:20 ## Creating a vector populated with the values from 1 to 20 in their respective positions.
x
```

## Data Types

R has 5 basic or "atomic" classes of objects:

- character  
- numeric  
- integer  
- complex  
- logical (boolean)  

## Objects 
The most basic object is a vector

- A vector can only contain objects of the same class  
- *list* is a vector that can contain different classes  

Empty vector is created by the vector() function.

## Numbers

Numbers in R are always treated as doubles. If you want an integer specifically you need to use the L suffix (ex. 1 is double, 1L is an integer). Inf is a special number which represents infinity. Also represented as (1/0). NaN represents an undefined value or missing number.

## Attributes

R objeccts can have attributes
- names,dimnames  
- dimensions  
- class  
- length  
- other user-defined attributes/metadata  

Attributes of an objeect can be accessed using the attributes() functions.

## Creating Vectors

The c() function can be used to create vectors of objects

```{r}
x <- c(.5,.6) ## numeric
x
x<- c(TRUE, TRUE) ## boolean
x 
x <- c(T,F)
x
x <- c("a","b","c")
x
x <- 9:29 ## integer
x
x <- c(1+0i,2+4i) ## Complex
x
```

Or using the vector() function

```{r}
x <- vector("numeric", length = 10)
x
```

What about mixing objects?

```{r}
y <- c(1.7,"a") ## char
y
y <- c(T,2) ##numeric
y
y<- c("a", TRUE) ##Char
y
```
They get coerced to the common denominator class

## Explicit coercion

Whay if you want to coerced something instead of letting the machine assume it? You can use the as."" () function.

```{r}
x <- 0:6
class(x)
as.numeric(x)
class(as.numeric(x))
as.logical(x)
as.character(x)
```

Nonsensical coercion results in NA s

## List

Vectors with different classes of opbjects

```{r}
x <- list(1,"a",TRUE,1+4i,2+0i)
x
```
## Matrices


matrices are vectors with an dimension attribute. The dimension attribute is itself an integer vector og length 2 (nrow,ncol)

```{r}
m <- matrix(nrow=2,ncol = 3)
m
dim(m)
attributes(m)
```

Matrices are constructed column wise, so entries can thought of starting in the upper left and running down the column

They can alse be created directly from vectors by adding dimension atribute

```{r}
m<-1:10
dim(m) <- c(2,5)
m
```

### cbind-ing and rbind-ing

Matrices can be created by colunm binding or row binding with `cbind()`  and `rbind()`

```{r}
x <- 1:3
y <- 10:12
cbind (x,y)
rbind(x,y)

```

## Factors

Factors are used to represent categorical data. Factors can be ordered or unordered. one can think of a factor as an integer vector where each integer has a label.

- Factors are treated specially by modelling function lime `lm()` and `glm()`  
- Using factors with labels is better than using integers because factors are self describing; having a variable that has values "Male"  and "Female" is better than a variable that has value 1 and 2.  

```{r}
x <- factor(c("yes", "yes","no", "yes", "no"))
x
table(x)
unclass(x)
```
The order of the levels can be set using the `levels` argument to `factor()`. This can be important in linear modelling because the first level is used as the baseline level.

```{r}
x <- factor(c("yes","yes","no","yes","no"),levels = c("yes","no"))
x
unclass(x)
```

## Missing values

Msiing values are denoted by `NA` or `NaN` for undefined mathematical operations.

- `is.na()` is used to test objects if they are NA  
- `is.nan()`  same for NaN  
- NA values have a class also, so there are integer NA, char NA, etc  
- A NaN value is also NA but the converse is not true  

## Data Frames

Data frames are used to store tabular data

- They are represented as a special type opf list where every element of the list has to have the same length  
- Each element of the list can be though of as a column and the length of each element of the list is the number of rows  
- Unlike matrices, data frames can store different classes of objects in each column; matrices must have every element be the same class   
- Data frames also have a special attribute called `row.names`  
- Data frames are usually created by calling `read.table()` or `read.csv()`  
- Can be converted to a matrix by calling `data.matrix()`  

```{r}
x <- data.frame(foo = 1:4, bar = c(T,T,F,F))
x
nrow(x)
ncol(x)
```
## Name Attribute

R objects can also have names, which is very useful for writing readable code and self-describing objects

```{r}
x<-1:3
names(x)
names(x) <- c("foo","bar", "norf")
x
names(x)
```

List can also have names

```{r}
x<-list(a=1,b=2, c=3)
x
```
and matrices
```{r}
m<-matrix(1:4,nrow =2, ncol = 2)
dimnames(m) <- list(c("a","b"),c("c","d"))
m
```
## Summary

Data types

- Atomic classes:numeric, logical,char,int,complex  
- vectors, list  
- factors  
- missing values  
- data frames  
- names  














